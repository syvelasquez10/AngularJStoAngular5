/*
 * generated by Xtext 2.12.0
 */
package co.edu.uniandes.angular.serializer;

import angularjs2angular5.angular.AngularPackage;
import angularjs2angular5.angular.Anotacion;
import angularjs2angular5.angular.AppAngular;
import angularjs2angular5.angular.Componente;
import angularjs2angular5.angular.CurlyBraces;
import angularjs2angular5.angular.Directiva;
import angularjs2angular5.angular.Expresion;
import angularjs2angular5.angular.Filtro;
import angularjs2angular5.angular.Funcion;
import angularjs2angular5.angular.Modulo;
import angularjs2angular5.angular.Propiedad;
import angularjs2angular5.angular.SentenciaHTML;
import angularjs2angular5.angular.Service;
import angularjs2angular5.angular.Template;
import angularjs2angular5.angular.Variable;
import co.edu.uniandes.angular.services.AngularDslGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AngularDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AngularDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AngularPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AngularPackage.ANOTACION:
				sequence_Anotacion(context, (Anotacion) semanticObject); 
				return; 
			case AngularPackage.APP_ANGULAR:
				sequence_AppAngular(context, (AppAngular) semanticObject); 
				return; 
			case AngularPackage.COMPONENTE:
				sequence_Componente(context, (Componente) semanticObject); 
				return; 
			case AngularPackage.CURLY_BRACES:
				sequence_CurlyBraces(context, (CurlyBraces) semanticObject); 
				return; 
			case AngularPackage.DIRECTIVA:
				sequence_Directiva(context, (Directiva) semanticObject); 
				return; 
			case AngularPackage.EXPRESION:
				sequence_Expresion(context, (Expresion) semanticObject); 
				return; 
			case AngularPackage.FILTRO:
				sequence_Filtro(context, (Filtro) semanticObject); 
				return; 
			case AngularPackage.FUNCION:
				sequence_Funcion(context, (Funcion) semanticObject); 
				return; 
			case AngularPackage.MODULO:
				sequence_Modulo(context, (Modulo) semanticObject); 
				return; 
			case AngularPackage.PROPIEDAD:
				sequence_Propiedad(context, (Propiedad) semanticObject); 
				return; 
			case AngularPackage.SENTENCIA_HTML:
				sequence_SentenciaHTML(context, (SentenciaHTML) semanticObject); 
				return; 
			case AngularPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case AngularPackage.TEMPLATE:
				sequence_Template(context, (Template) semanticObject); 
				return; 
			case AngularPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Anotacion returns Anotacion
	 *
	 * Constraint:
	 *     (name=EString primitivo=EBoolean value=EString)
	 */
	protected void sequence_Anotacion(ISerializationContext context, Anotacion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AngularPackage.Literals.ANOTACION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AngularPackage.Literals.ANOTACION__NAME));
			if (transientValues.isValueTransient(semanticObject, AngularPackage.Literals.ANOTACION__PRIMITIVO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AngularPackage.Literals.ANOTACION__PRIMITIVO));
			if (transientValues.isValueTransient(semanticObject, AngularPackage.Literals.ANOTACION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AngularPackage.Literals.ANOTACION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnotacionAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAnotacionAccess().getPrimitivoEBooleanParserRuleCall_4_0(), semanticObject.isPrimitivo());
		feeder.accept(grammarAccess.getAnotacionAccess().getValueEStringParserRuleCall_6_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AppAngular returns AppAngular
	 *
	 * Constraint:
	 *     (modulos+=Modulo | componentes+=Componente | services+=Service | templates+=Template)
	 */
	protected void sequence_AppAngular(ISerializationContext context, AppAngular semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjetoAngular returns Componente
	 *     Componente returns Componente
	 *
	 * Constraint:
	 *     (
	 *         modulo=[Modulo|EString] 
	 *         name=EString 
	 *         template=[Template|EString] 
	 *         (parametros+=[ObjetoAngular|EString] parametros+=[ObjetoAngular|EString]*)* 
	 *         funcion=Funcion
	 *     )
	 */
	protected void sequence_Componente(ISerializationContext context, Componente semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CurlyBraces returns CurlyBraces
	 *
	 * Constraint:
	 *     (expresion=Expresion filtro=Filtro?)
	 */
	protected void sequence_CurlyBraces(ISerializationContext context, CurlyBraces semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Directiva returns Directiva
	 *
	 * Constraint:
	 *     (name=EString curlybraces=[CurlyBraces|EString]? referencia=[ObjetoAngular|EString])
	 */
	protected void sequence_Directiva(ISerializationContext context, Directiva semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expresion returns Expresion
	 *
	 * Constraint:
	 *     (valor=EString referencia=[ObjetoAngular|EString])
	 */
	protected void sequence_Expresion(ISerializationContext context, Expresion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AngularPackage.Literals.EXPRESION__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AngularPackage.Literals.EXPRESION__VALOR));
			if (transientValues.isValueTransient(semanticObject, AngularPackage.Literals.EXPRESION__REFERENCIA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AngularPackage.Literals.EXPRESION__REFERENCIA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpresionAccess().getValorEStringParserRuleCall_1_0(), semanticObject.getValor());
		feeder.accept(grammarAccess.getExpresionAccess().getReferenciaObjetoAngularEStringParserRuleCall_2_0_1(), semanticObject.eGet(AngularPackage.Literals.EXPRESION__REFERENCIA, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filtro returns Filtro
	 *
	 * Constraint:
	 *     parametros=EString
	 */
	protected void sequence_Filtro(ISerializationContext context, Filtro semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AngularPackage.Literals.FILTRO__PARAMETROS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AngularPackage.Literals.FILTRO__PARAMETROS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFiltroAccess().getParametrosEStringParserRuleCall_2_0(), semanticObject.getParametros());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Funcion returns Funcion
	 *
	 * Constraint:
	 *     (name=EString parametros=EString variables+=Variable* body=EString)
	 */
	protected void sequence_Funcion(ISerializationContext context, Funcion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjetoAngular returns Modulo
	 *     Modulo returns Modulo
	 *
	 * Constraint:
	 *     (name=EString (parametros+=[ObjetoAngular|EString] parametros+=[ObjetoAngular|EString]*)*)
	 */
	protected void sequence_Modulo(ISerializationContext context, Modulo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Propiedad returns Propiedad
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Propiedad(ISerializationContext context, Propiedad semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AngularPackage.Literals.PROPIEDAD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AngularPackage.Literals.PROPIEDAD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropiedadAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SentenciaHTML returns SentenciaHTML
	 *
	 * Constraint:
	 *     (name=EString propiedades+=Propiedad* directivas+=Directiva* curlybraces+=CurlyBraces* sentenciashtml+=[SentenciaHTML|EString]*)
	 */
	protected void sequence_SentenciaHTML(ISerializationContext context, SentenciaHTML semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjetoAngular returns Service
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (modulo=[Modulo|EString] name=EString (parametros+=[ObjetoAngular|EString] parametros+=[ObjetoAngular|EString]*)* funcion=Funcion)
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Template returns Template
	 *
	 * Constraint:
	 *     (name=EString sentenciashtml+=SentenciaHTML*)
	 */
	protected void sequence_Template(ISerializationContext context, Template semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (anotacion=Anotacion? name=EString valor=EString)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
